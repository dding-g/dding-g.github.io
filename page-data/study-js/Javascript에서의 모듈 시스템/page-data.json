{"componentChunkName":"component---src-templates-blog-post-js","path":"/study-js/Javascript에서의 모듈 시스템/","result":{"data":{"site":{"siteMetadata":{"title":"dding-glog"}},"markdownRemark":{"id":"17ed788f-6625-55cb-9080-da695448e148","excerpt":"Javascript 모듈 시스템 모듈(module…","html":"<h2>Javascript 모듈 시스템</h2>\n<p>모듈(module)은 어플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 의미한다.\n보통 모듈은 기능을 기준으로 파일 단위로 분리한다. 이때 모듈이 성립하려면 모듈은 자신만의 파일 스코프(모듈 스코프)를 가질 수 있어야 한다.\n자신만의 파일 스코프를 갖는 모듈의 모든 자산(변수, 함수 등)은 기본적으로 비공개 상태이다.\n즉, 캡슐화가 되어있어서 다른 모듈에서 접근할 수 없다.\n모듈은 개별적인 존재로서 애플리케이션과 분리되어 존재한다.</p>\n<p>하지만 애플리케이션에서 사용할 수 없는 모듈은 의미가 없기 때문에,\n모듈은 공개가 필요한 자산에 한정하여 명시적으로 선택적 공개가 가능하다. === <code class=\"language-text\">export</code> 라고 한다.\n이렇게 공개(export)한 모듈의 자산은 다른 모듈에서 재사용 할 수 있고\n모듈 사용자는 모듈이 공개한 자산 중 일부 또는 전체를 선택해 자신의 스코프 내로 불러들여 재사용 할수 있다. === <code class=\"language-text\">import</code> 라고 한다.</p>\n<p>과거 Javascript 환경에서는 모듈 시스템이 존재하지 않았다.\nscript 태그로 분리하여 사용해도 결국은 하나의 Javascript 파일 내부에서 동작하는 것 처럼 실행되었다.\n이떄 제시된 모듈 시스템이 <code class=\"language-text\">CommonJS, AMD</code> 이다.\nNode.js는 사실상 표준이였던 <code class=\"language-text\">CommonJS</code>를 채택했다.</p>\n<p>이런 상황에서 ES6에서는 클라이언트 사이드 Javascript에서도 동작하는 모듈 기능을 추가했다. === <code class=\"language-text\">ESM</code>\n<code class=\"language-text\">script</code>태그에 <code class=\"language-text\">type=\"module\"</code> 어트리뷰트를 추가하면 로드된 Javascript 파일은 모듈로서 동작한다.</p>\n<p>Javasript에서 모듈 시스템은 크게 4가지로 나눌 수 있다.</p>\n<ol>\n<li>ESM</li>\n<li>CommonJS</li>\n<li>AMD</li>\n<li>UMD</li>\n</ol>\n<h3>ESM</h3>\n<p>요즘 <a href=\"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\"><code class=\"language-text\">Pure ESM</code></a> 을 지원하는 디펜던시가 많아졌다.\nCommonJS, ESM 둘 다 지원할 수 있지만 굳이 ESM만을 지원하겠다 라는 선언인데, 클리이언트 사이드 Javascript는 ES6를 지원하니 상관없지만 CommonJS로 동작하는 Node.js 환경은 말이 다르다.\nCJS와 ESM은 모듈 import/export 과정부터 다르다.\nESM은 비동기로 이루어 지고 CJS는 동기적으로 이루어지는데, 이런 이유 때문에 일반적인 방법으로는 <code class=\"language-text\">CJS</code>에서 <code class=\"language-text\">ESM</code> 모듈을 불러 올 수 없다.\nCJS에서 <code class=\"language-text\">dynamic import</code> 로 파일을 불러오거나 <code class=\"language-text\">ESM</code>프로젝트로 변환해야한다.</p>\n<p>회사 프로젝트에 typescript가 도입될 걸 고려해서 CJS → ESM 으로 변경하려고 시도했는데, 레거시가 많고 CJS 프로젝트에서 <code class=\"language-text\">global</code>이나 <code class=\"language-text\">__path</code> <code class=\"language-text\">__dirname</code> 처럼 ESM에서 지원하지 않는 기능을 많이 사용했고, 덩치가 너무 커서 변환을 시도하다 멈췄다.</p>\n<ul>\n<li><a href=\"https://yceffort.kr/2020/08/commonjs-esmodules\">CommonJS와 ES Modules은 왜 함께 할 수 없는가?</a>\n<ul>\n<li>변역글인데, 이 글에서는 CJS가 향후 Javascript의 미래가 될 거라 판단했다.</li>\n</ul>\n</li>\n</ul>\n<h3>CommonJS</h3>\n<p>Javascript에 모듈화를 도입했던 선두주자.\n<code class=\"language-text\">모듈</code>은 위에서 말했다시피 다른 모듈이 접근할 수 없는 자신만의 독립적인 영역(<code class=\"language-text\">Scope</code>)을 가지는게 중요하다. 또한 선택적으로 외부에 공개(<code class=\"language-text\">export</code>) 할 수 있어야 하고 다른 모듈을 가져올 수 있어야 한다.(<code class=\"language-text\">import</code>)\nCommonJS는 이런 조건을 모두 만족했고 Node.js의 기본값으로 채택되었으나,\nES Modules은 Javascript의 표준이 되었다.</p>\n<hr>\n<ul>\n<li><a href=\"https://blog.logrocket.com/commonjs-vs-es-modules-node-js/\">CommonJS vs. ES modules in Node.js</a>\n<ul>\n<li>Node.js version 9 이하에서는 ESM이 지원되지 않는걸 고려해야한다.</li>\n<li>Node.js의 기본값은 CommonJS이고 Javascript의 표준은 ESM이기 때문에 둘 다 유용하다. 하지만 CommonJS 프로젝트를 ESM으로 마이그레이션하는건 좋은 선택이 아닐 수 있다.</li>\n<li>ESM이 Javascript의 미래다.</li>\n</ul>\n</li>\n</ul>\n<p>ESM과 CJS를 두고 벌이는 논쟁은 정말 많다. Pure ESM의 댓글만 봐도 수많은 의견들을 주고받는걸 볼 수 있다.\n하지만 Pure ESM에 대한 방향성도 그렇고 CommonJS 보다 ESM으로 흘러가는 것 같다.\nESM은 CJS를 수용할 수 있으나 CJS는 ESM을 수용하기 까다롭기 때문이다.</p>","frontmatter":{"title":"Javascript에서의 모듈 시스템","date":"July 22, 2022","description":"CommonJS와 ES Module에 대해.","tags":["Javascript"]}},"previous":{"fields":{"slug":"/coding-test/BOJ-1038/"},"frontmatter":{"title":"BOJ-1038"}},"next":{"fields":{"slug":"/study-js/호이스팅이 무엇인가요/"},"frontmatter":{"title":"호이스팅이 무엇인가요"}}},"pageContext":{"id":"17ed788f-6625-55cb-9080-da695448e148","previousPostId":"d28038f0-180f-5bea-90d3-433c6780b590","nextPostId":"508ab013-3cc0-5051-8f51-4f5f6afc9b54"}},"staticQueryHashes":["2841359383","3257411868"]}