{"componentChunkName":"component---src-templates-blog-post-js","path":"/study-js/webpack이 무엇인가요/","result":{"data":{"site":{"siteMetadata":{"title":"dding-glog"}},"markdownRemark":{"id":"32e096be-e29d-54c3-8e6f-64c946db4ace","excerpt":"정의 Webpack Document 첫줄에 이렇게 안내하고있다. 은 Javascript 애플리케이션을 위한 정적 모듈 번들러 이다.  Javascript는 ES6, CJS…","html":"<h2>정의</h2>\n<p><a href=\"https://webpack.kr/concepts/\">Webpack Document</a> 첫줄에 이렇게 안내하고있다.</p>\n<p><code class=\"language-text\">webpack</code>은 Javascript 애플리케이션을 위한 <strong>정적 모듈 번들러</strong> 이다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">모듈</code></p>\n<ul>\n<li>Javascript는 ES6, CJS와 같은 <a href=\"../Javascript%EC%97%90%EC%84%9C%EC%9D%98%20%EB%AA%A8%EB%93%88%20%EC%8B%9C%EC%8A%A4%ED%85%9C/index.md\">모듈 시스템</a>이 존재하는데, 핵심은 <code class=\"language-text\">코드의 스코프를 나눠 파일 단위로 관리한다.</code> 이다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">번들러</code></p>\n<ul>\n<li>“번들” 이라는 것은 무엇을 하나로 묶는 작업이다. <code class=\"language-text\">XXX 번들러</code> 라고 한다면 <code class=\"language-text\">XXX</code> 를 하나로 묶는 도구를 말한다.</li>\n</ul>\n</li>\n</ul>\n<p>따라서 <code class=\"language-text\">Webpack</code>을 풀어쓰면</p>\n<p><strong>파일 단위로 나뉜 Javascript 코드를 하나의 파일로 묶는 도구</strong> 라고 할 수 있다.</p>\n<p>여기엔 Javascript 파일 뿐만 아니라 CSS, Image, HTML 파일도 포함이다.</p>\n<p>과거 Single Page Application 아닌 여러 HTML 파일로 이루어진 페이지 에서는 각 페이지별로 로드되는 Javascript 파일이나 CSS 파일이 달랐다.</p>\n<p>하지만 SPA로 넘어오면서 하나의 페이지를 동적으로 관리하다보니 Javascript 전체를 로드해야 하는 상황이 생겼고 파일이 많아지면 많아질수록 한정된 네트워크 자원에서 쾌적하게 사용하기는 힘들었다.</p>\n<p>이런 단점을 보완하기 위해 최소화된 파일 개수, 파일 크기를 만들어야 했고 트리쉐이킹 등 파일 사이즈를 줄이는 작업과 함께 <code class=\"language-text\">번들러</code> 라는 개념이 등장했다.</p>\n<p>여기서는 Webpack을 다루지만 <code class=\"language-text\">rollup</code> <code class=\"language-text\">parcel</code> 등 수많은 Javascript 번들러가 존재한다.</p>\n<h2>동작 방식</h2>\n<p>Webpack은 내부적으로 <code class=\"language-text\">Entry Point(시작점)</code> 부터 <a href=\"https://webpack.kr/concepts/dependency-graph/\">디펜던시 그래프</a>를 생성한다.\n이렇게 재귀적으로 디펜던시 그래프를 생성하고 모든 모듈을 하나의 <code class=\"language-text\">.js</code> 파일로 만들어 <code class=\"language-text\">Output</code> 옵션에 설정 된 경로로 내보낸다.</p>\n<p>이 과정에서 <code class=\"language-text\">Webpack</code>은 기본적으로 Javascript 파일과 JSON 파일만 인식한다.</p>\n<p>따라서 CSS 와 같은 파일을 번들링하기 위해서는 Webpack이 로드할 수 있도록 모듈로 변환하여 디펜던시 그래프에 추가되도록 해야한다. 이 과정에서 사용되는걸 <code class=\"language-text\">Loader(로더)</code>라고 한다.</p>\n<p>기본적인 모듈 변환 이외에 번들 최적화, 에셋 관리, uglify 등 추가적으로 다양한 작업을 하기 위해서는 <code class=\"language-text\">Plugins(플러그인)</code>이 필요하다. 로더는 번들링을 위해 필요하지만, 플러그인은 번들링이 완료된 파일을 대상으로 처리한다.</p>\n<p>webpack에 내장된 실행 환경별(production, development) 최적화 세팅을 사용하려면 <a href=\"https://webpack.kr/configuration/mode\"><code class=\"language-text\">Mode</code></a>를 사용한다. develoment 모드 일 때는 트리쉐이킹 같은 코드 최적화를 진행하지 않으니 유의해야한다.</p>\n<h2>트리쉐이킹</h2>\n<p>나무를 흔들면 잔가지들이 우수수 떨어지는걸 본 적이 있을것이다.</p>\n<p>이런 점에서 Webpack은 쓸모없는, 더이상 사용하지 않는 코드는 번들링에서 제외하고 최적화된 파일을 내보내고 싶어한다.</p>\n<p>예를들어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// BAD</span>\n<span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> test1 <span class=\"token keyword\">from</span> <span class=\"token string\">\"./test1\"</span>\n<span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> test2 <span class=\"token keyword\">from</span> <span class=\"token string\">\"./test2\"</span>\n<span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> test3 <span class=\"token keyword\">from</span> <span class=\"token string\">\"./test3\"</span>\n\n<span class=\"token comment\">// GOOD</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> testFn <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./test1\"</span>\n<span class=\"token keyword\">import</span> testTwo <span class=\"token keyword\">from</span> <span class=\"token string\">\"./test2\"</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> testFn3 <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./test3\"</span></code></pre></div>\n<p>첫번째 각 파일의 모든 모듈을 가져온다. 사용하지 않는 모듈이라고 할지라도 가져와서 사용할 수 있도록 상위 스코프에 붙인다.</p>\n<p>따라서 아래 예시 처럼 사용하는 함수만 가져오거나 default로 export된 모듈만 가져오는거로도 트리쉐이킹을 할 수 있다.</p>\n<p>webpack4 부터는 <code class=\"language-text\">sideEffects</code> 라는 속성을 지원하며 모듈 단위로 사용되지 않는 모듈은 제거한다.</p>\n<p><a href=\"https://github.com/terser/terser\"><code class=\"language-text\">terser</code></a> 플러그인과 같이 사용할 수 있다.</p>\n<p><code class=\"language-text\">terser</code>는 구문 단위로 사이드 이펙트를 감지하지만 여러 상황 속에서 정확하게 사용되지 않는 코드라고 구문을 보고 분석하는건 쉽지 않다. 예를 들어 아래처럼 조건을 통해 사용되거나, 되지 않는 경우를 판별하는 경우가 그렇다. <a href=\"https://webpack.kr/guides/tree-shaking/#clarifying-tree-shaking-and-sideeffects\">여기</a> 코드를 참조하자.</p>\n<p>그래서 <code class=\"language-text\">/*#__PURE__*/</code> 같은 주석을 사용해서 개발자가 정할 수 있도록 한다.\n해당 코드가 여러 조건을 통해서 사용 되거나, 되지 않거나를 정하는 것 처럼\n<code class=\"language-text\">사이드 이팩트</code>가 생길 여지가 있는지, 없는지를 개발자가 판단하고 <code class=\"language-text\">PURE</code> 여부를 정한다.</p>\n<p>마지막으로 <a href=\"https://webpack.kr/guides/tree-shaking/#conclusion\">Document</a> 에서는 아래와 같은 결론을 내린다.</p>\n<blockquote>\n<ul>\n<li>ES2015 모듈 구문을 사용해야 하는 것을 배웠습니다. (예: import와 export)</li>\n<li>컴파일러가 ES2015 모듈 구문을 CommonJS 모듈로 변환하지 않도록 해야 합니다. (이것은 인기 있는 Babel preset @babel/preset-env의 기본 동작입니다. 자세한 내용은 documentation를 참고하세요.)</li>\n<li>package.json 파일에 “sideEffects” 속성을 추가하세요.</li>\n<li>최소화와 tree shaking을 포함한 다양한 최적화를 사용하려면 production mode 설정 옵션을 사용하세요.</li>\n</ul>\n</blockquote>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://ui.toast.com/fe-guide/ko_BUNDLER\">https://ui.toast.com/fe-guide/ko_BUNDLER</a></li>\n<li><a href=\"https://velog.io/@yon3115/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%95%84%EC%88%98-Webpack%EC%9D%B4%EB%9E%80\">https://velog.io/@yon3115/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%95%84%EC%88%98-Webpack%EC%9D%B4%EB%9E%80</a></li>\n<li><a href=\"https://webpack.kr/concepts/\">https://webpack.kr/concepts/</a></li>\n</ul>","frontmatter":{"title":"webpack이 무엇인가요?","date":null,"description":"webpack이 무엇인지 간단하게 풀어 쓴 글","tags":["Javascript","Frontend"]}},"previous":{"fields":{"slug":"/study-js/이벤트 루프는 무엇인가요/"},"frontmatter":{"title":"이벤트 루프는 무엇인가요?"}},"next":{"fields":{"slug":"/study-js/스코프(Scope)가 무엇인가요/"},"frontmatter":{"title":"스코프(Scope)가 무엇인가요?"}}},"pageContext":{"id":"32e096be-e29d-54c3-8e6f-64c946db4ace","previousPostId":"c1b55758-385f-57f4-8ee7-c89110842a2d","nextPostId":"360988e7-c7b6-53a4-ae18-336968846fc8"}},"staticQueryHashes":["2841359383","3257411868"]}