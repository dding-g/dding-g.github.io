{"componentChunkName":"component---src-templates-blog-post-js","path":"/study-js/프로토타입(prototype)이 무엇인가요/","result":{"data":{"site":{"siteMetadata":{"title":"dding-glog"}},"markdownRemark":{"id":"4cd71bb2-523e-58d4-96f3-8d8c009c24fd","excerpt":"small  책을 공부하면서 정리했습니다. 왜 Javascript에서는 프로토타입을 사용하는가? Javascript…","html":"<p><img src=\"http://image.yes24.com/goods/92742567/XL\" alt=\"small\"></p>\n<p><strong><code class=\"language-text\">모던 자바스크립트 Deep Dive</code> 책을 공부하면서 정리했습니다.</strong></p>\n<h2>왜 Javascript에서는 프로토타입을 사용하는가?</h2>\n<p>Javascript는 명령형, 함수형, 프로토타입 기반, 객체지향 프로그래밍을 지원하는 멀티 페러다임 언어이다.\n<code class=\"language-text\">객체지향</code>은 실세계의 실체(사물, 개념)을 인식하는 철학적 사고를 프로그래밍에 접합하려는 시도에서 시작했다.\n사람은 이름, 주소, 신발사이즈, 키, 몸무게 등 수많은 정보를 가지고 있지만, 프로그래밍에서 사용되는 데이터만 뽑아 정의한걸 <code class=\"language-text\">추상화(abstract)</code> 라고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">name</span> <span class=\"token operator\">:</span> <span class=\"token string\">'ddingg'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">address</span><span class=\"token operator\">:</span> <span class=\"token string\">'seoul'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또한 <code class=\"language-text\">상속</code>은 객체지향 프로그래밍의 핵심 개념으로 코드를 재사용 함으로써 불필요한 중복을 제거하는게 의미가 있다.</p>\n<p>Javascript에서 상속은 <code class=\"language-text\">prototype</code>을 이용해서 구현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Circle</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">radius</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>radius <span class=\"token operator\">=</span> radius\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">Circle</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">getArea</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token constant\">PI</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>radius <span class=\"token operator\">*</span> <span class=\"token number\">2</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> c1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Circle</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> c2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Circle</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c1<span class=\"token punctuation\">.</span>getArea <span class=\"token operator\">===</span> c2<span class=\"token punctuation\">.</span>getArea<span class=\"token punctuation\">)</span> <span class=\"token comment\">// true</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c1<span class=\"token punctuation\">.</span><span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> c2<span class=\"token punctuation\">.</span><span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// false</span></code></pre></div>\n<p>위에서 본 것 처럼 c1, c2의 <code class=\"language-text\">getArea</code> 함수는 prototype으로 만들어진 상속받은 객체이기 때문에 같은 값 이라고 판별한다. (상속에 의한 메서드 공유)</p>\n<hr>\n<h2>프로토타입은 무엇인가?</h2>\n<p>자 이제 <code class=\"language-text\">prototype</code> 객체에 대해 살펴보자.\n프로토타입 객체는 객체간 상속을 구현하기 위해 사용된다.\n즉 상속받은 자식 객체는 부모 객체의 <code class=\"language-text\">property</code>를 자유롭게 사용할 수 있다.</p>\n<p>모든 객체는 <code class=\"language-text\">[[Prototype]]</code> 이라는 내부 슬롯을 가진다.\n여기에 저장되는 프로토타입은 객체 생성 방식에 의해 결정된다.</p>\n<p>예를들어 객체 리터럴로 생성된 객체는 <code class=\"language-text\">Object.prototype</code>을 가지고 있다고 하지만, 생성자 함수에 의해 생성된 객체는 생성자 함수의 <code class=\"language-text\">prototype</code> 프로퍼티에 바인딩 되어 있는 객체이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 객체 리터럴</span>\n<span class=\"token keyword\">const</span> Person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ddingg\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">address</span><span class=\"token operator\">:</span> <span class=\"token string\">\"seoul\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 생성자 함수</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span> address</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>address <span class=\"token operator\">=</span> address\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">[[Prototype]]</code> 내부 슬롯에는 직접 접근할 수 없지만 <code class=\"language-text\">__proto__</code> 접근자 프로퍼티로 할당된 <code class=\"language-text\">prototype</code>에 접근할 수 있다.\n이건 객체가 직접 소유하는 프로퍼티가 아니라 <code class=\"language-text\">Object.prototype</code>의 프로퍼티이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> parent <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ddingg\"</span> <span class=\"token punctuation\">}</span>\n\nobj<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">=</span> parent\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span> <span class=\"token comment\">// ddingg</span></code></pre></div>\n<p>왜 굳이?? <code class=\"language-text\">__proto__</code>를 사용해서 prototype 에 접근하고 할당하는 방법을 알아야할까?\n상호 참조에 의해 프로토타입 체인이 생성되는걸 방지하기 위해서 이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> parent <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// BAD : 상호참조</span>\nchild<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">=</span> parent\nparent<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">=</span> child</code></pre></div>\n<p>프로토타입 체인은 linked list. 즉 단방향으로 구현되어야 한다.\n따라서 아무런 체크없이 무조건 적으로 프로토타입을 교체할 수 없도록 <code class=\"language-text\">__proto__</code> 를 사용해 접근하고 교체하도록 하는 것이다.</p>\n<p>함수 객체는 생성자 함수가 존재하기 때문에 prototype을 갖지만 arrow-function의 경우는 생성자 함수가 존재하지 않기 떄문에 prototype을 갖지 않는다. (익명 함수의 경우는 생성자 함수를 갖는다.)\n즉, <code class=\"language-text\">생성자(constructor)</code>와 <code class=\"language-text\">프로토타입</code>은 항상 쌍으로 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 객체 리터럴</span>\n<span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//함수 리터럴</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 배열 리터럴</span>\n<span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">//정규 표현식 리터럴</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">is</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">gi</span></span></code></pre></div>\n<p>위 리터럴 표기법에 의해 생성된 객체도 prototype이 존재한다.</p>\n<hr>\n<h2>프로토타입 생성 시점</h2>\n<p>사용자 프로토타입은 constructor 함수 정의가 평가되어 객체를 생성하는 시점에 생성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span> <span class=\"token comment\">// [constructor: f]</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>빌트인 생성자 함수 (Object, String, Number, Array, Function, RegExp, Date, Promise 등등..)도 마찬가지로 생성자 함수가 생성되는 시점에 프로토타입이 생기는데, 모든 빌트인 함수는 전역 객체가 생성되는 시점에 생성된다.\n전역 객체는 코드가 실행되기 전 Javascript 엔진에 의해 생성된다.</p>\n<h2>프로토타입 체인</h2>\n<p>Javascript 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <code class=\"language-text\">[[Prototype]]</code> 내부 슬롯의 참조를 따라 부모 프로토타입의 프로퍼티를 순차적으로 탐색한다.\n이를 프로토타입 체인이라고 하고 Javascript가 상속을 구현하는 방법이다.\n최상위는 언제나 <code class=\"language-text\">Object.prototype</code> 이고 여기 <code class=\"language-text\">[[Prototype]]</code> 슬롯은 항상 null이다.</p>\n<h2>오버라이딩과 프로퍼티 섀도잉</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n<span class=\"token punctuation\">}</span>\n\nPerson<span class=\"token punctuation\">.</span>property<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHello</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hi Persion!\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> me <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ddingg\"</span><span class=\"token punctuation\">)</span>\n\nme<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHello</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hi Me!\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nme<span class=\"token punctuation\">.</span><span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// Hi Me! ddingg</span></code></pre></div>\n<p>이런식으로 부모 객체의 함수와 같은 이름으로 자식에서 함수를 만들게 되면\n자식에서 선언한 함수가 프로토타입 체인에 따라 먼저 검색되고 호출된다.\n따라서 부모의 프로퍼티는 가려지는 것 처럼 보이는데 이걸 <code class=\"language-text\">프로퍼티 섀도잉</code> 이라고 한다.</p>\n<p>오버라이딩은 이런 방식으로 구현되는데, Javascript에서는 매개변수에 따라 함수 호출이 변하지는 않기 때문에 <code class=\"language-text\">arguments</code> 를 사용해서 오버로딩처럼 동작하도록 만들 수 있다.</p>\n<h2>instanceof</h2>\n<p><code class=\"language-text\">instanceof</code> 연산자는 프로토타입의 생성자 함수를 프로토타입 체인에 따라 검색하면서 존재하는지 확인한다. 함수로 표현하면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">isInstanceof</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">instance<span class=\"token punctuation\">,</span> constructor</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> prototype <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">getPropertyOf</span><span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// prototype chain end</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prototype <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n\n  <span class=\"token keyword\">return</span> prototype <span class=\"token operator\">===</span> constructor <span class=\"token operator\">||</span> <span class=\"token function\">isInstanceof</span><span class=\"token punctuation\">(</span>prototype<span class=\"token punctuation\">,</span> constructor<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>for…in</h2>\n<p>객체의 <code class=\"language-text\">프로퍼티</code> 를 열거할 때 사용한다.\n프로토타입 체인 상에 존재하는 모든 프로토타입 프로퍼티 중 <code class=\"language-text\">[[Enumerable]]</code>의 값이 <code class=\"language-text\">true</code>인 프로퍼티를 열거한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ddingg\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">address</span><span class=\"token operator\">:</span> <span class=\"token string\">\"seoul\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> key <span class=\"token keyword\">in</span> person<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/**\n   * name : ddingg\n   * address : seoul\n   */</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> <span class=\"token string\">\" : \"</span><span class=\"token punctuation\">,</span> person<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">for...of</code> 와 다른점은 <code class=\"language-text\">for...of</code>는 객체 iterator만 평가하며 iterator의 <code class=\"language-text\">value</code>를 가져오고 <code class=\"language-text\">for...in</code>은 모든 객체를 평가하지만 <code class=\"language-text\">key</code>를 가져온다.</p>\n<p><code class=\"language-text\">[...values]</code> → <code class=\"language-text\">for...of</code>, <code class=\"language-text\">Object.values</code>\n<code class=\"language-text\">[...keys]</code> → <code class=\"language-text\">for...in</code>, <code class=\"language-text\">Object.keys</code>\n<code class=\"language-text\">[[...keys], [...values]]</code> → <code class=\"language-text\">Object.entries</code></p>","frontmatter":{"title":"프로토타입(prototype)이 무엇인가요?","date":null,"description":"Javascript에서 프로토타입은 무엇인가요?","tags":["Javascript"]}},"previous":{"fields":{"slug":"/study-js/호이스팅이 무엇인가요/"},"frontmatter":{"title":"호이스팅이 무엇인가요"}},"next":{"fields":{"slug":"/study-js/클로저가 무엇인가요/"},"frontmatter":{"title":"클로저(Closure)가 무엇인가요"}}},"pageContext":{"id":"4cd71bb2-523e-58d4-96f3-8d8c009c24fd","previousPostId":"92ce90f2-f7b3-5c0a-8959-374619a68c01","nextPostId":"f64cf150-2308-58cb-9dc5-3d5215314f77"}},"staticQueryHashes":["2841359383","3257411868"]}