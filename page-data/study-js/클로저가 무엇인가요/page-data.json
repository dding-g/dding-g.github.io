{"componentChunkName":"component---src-templates-blog-post-js","path":"/study-js/클로저가 무엇인가요/","result":{"data":{"site":{"siteMetadata":{"title":"dding-glog"}},"markdownRemark":{"id":"f64cf150-2308-58cb-9dc5-3d5215314f77","excerpt":"정의 컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 기능상으로, 클로저는 함수를 저장한 레코드(record)이며, 스코프(scope…","html":"<h2>정의</h2>\n<blockquote>\n<p>컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 기능상으로, 클로저는 함수를 저장한 레코드(record)이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, 스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.</p>\n</blockquote>\n<p>클로저는 Javascript의 고유 개념이 아니다.\nMDN에서는 <strong><code class=\"language-text\">클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다.</code></strong> 라고 정의하고 있다.\n아래 예제를 보자</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">outerFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">innerFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> innerFunction<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> innerFn <span class=\"token operator\">=</span> <span class=\"token function\">outerFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">innerFn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 10</span></code></pre></div>\n<p>왜 <code class=\"language-text\">10</code>이 출력될까?\n이건 Javascript가 <code class=\"language-text\">렉시컬 스코프</code> 를 따르고 있기 때문이다.\n<a href=\"../%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85(prototype)%EC%9D%B4%20%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/index.md\">프로토타입이 무엇인가요?</a> 를 살펴보면 프로퍼티를 탐색할때 prototype에 정의된 프로퍼티를 탐색하면서 부모 객체로 올라간다는걸 알 수 있다.\n그렇다면 여기서 innerFunction의 프로토타입은 <code class=\"language-text\">outerFunction</code>일까?\n아니다. <code class=\"language-text\">innerFunction</code>는 상속받지 않았고 <code class=\"language-text\">outerFunction</code>의 내부 함수일 뿐이다.\n그렇다면 <code class=\"language-text\">outerFunction</code>에 선언된 <code class=\"language-text\">x</code>는 어떻게 찾은 것 일까?</p>\n<p>함수 생명주기를 고려해서 실행되는 순서를 생각해보자.</p>\n<ol>\n<li><code class=\"language-text\">outerFunction</code>이 선언된다.</li>\n<li><code class=\"language-text\">outerFunction</code>이 실행된다.</li>\n<li><code class=\"language-text\">outerFunction</code>가 완료되면서 innerFunciton을 반환하고 <code class=\"language-text\">outerFunction</code>의 생명주기가 끝난다.</li>\n<li><code class=\"language-text\">innerFunction</code> 을 저장하고 실행한다.</li>\n<li>10이 출력된다.</li>\n</ol>\n<p>이미 <code class=\"language-text\">outerFunction</code>의 생명주기가 끝난 시점에서 <code class=\"language-text\">x</code>도 같이 생명주기를 마감한다. 하지만 실행 결과는 <code class=\"language-text\">outerFunction</code>의 <code class=\"language-text\">x</code>값인 10이 출력된다.</p>\n<p>이처럼 외부 함수(outerFunction)보다 중첩 함수(innerFunction)가 더 오래 유지되는 경우, 이미 생명주기가 종료된 외부 함수의 변수를 참조할 수 있다.\n<strong><code class=\"language-text\">이러한 중첩 함수를 클로저(Closure) 라고 부른다.</code></strong></p>\n<p><img src=\"/images/innerFnDebug.png\" alt=\"innerFnDebug.png\"></p>\n<p>디버거의 <code class=\"language-text\">[[Scopes]]</code> 부분을 보면 <code class=\"language-text\">Closure</code> → <code class=\"language-text\">Script</code> → <code class=\"language-text\">Global</code> 순으로 나열된 걸 볼 수 있다.</p>\n<hr>\n<h2>함수 객체의 내부 슬롯 <code class=\"language-text\">[[Enviroment]]</code></h2>\n<p>자 그렇다면 우리는 렉시컬 스코프를 가진 클로저가 이미 생명주기가 끝난 상위 스코프의 변수를 참조할 수 있다는걸 알았다.</p>\n<p>어떻게 이게 가능한걸까? 생명주기가 끝났음에도 GC에 의해 메모리가 초기화되어야 하는게 아닌가?</p>\n<p>그렇지않다.</p>\n<p>GC에 의해 메모리에서 정리되지 않는 이유는 <code class=\"language-text\">innerFunction</code>(클로저)에서 자신이 정의된 <code class=\"language-text\">outerFunction</code>(상위 스코프)를 기억하고 있기 때문이다.</p>\n<p><strong>함수는 이 정보를 자신의 내부 슬롯 <code class=\"language-text\">[[Enviroment]]</code>에 자신이 정의된 환경을 저장한다.</strong></p>\n<p>또한 “생명주기가 끝났다.” 라는건 실행 컨텍스트 스택에서 제거된다는 뜻이다.</p>\n<p>실행 컨텍스트에서 제거가 되는건 맞지만 클로저 함수의 <code class=\"language-text\">[[Enviroment]]</code> 에 저장된 상위 스코프의 렉시컬 환경까지 소멸하는 것은 아니다.</p>\n<p>따라서 아직 클로저 <code class=\"language-text\">innterFunction</code>에 의해 <code class=\"language-text\">outerFunction</code>는 참조받고 있기 때문에 GC는 <code class=\"language-text\">outerFunction</code>의 생명주기가 끝나도 메모리에서 해제하지 않는다.</p>\n<hr>\n<h2>결론</h2>\n<p>그렇다면 함수 안에 함수가 선언된 모든 함수를 우리는 클로저라고 불러야 할까?</p>\n<p>그렇게 되면 이론상 모든 함수는 클로저가 된다.</p>\n<p>답은 <code class=\"language-text\">모든 함수가 클로저는 아니다.</code> 이다.</p>\n<p>다시 MDN의 정의로 돌아가보면 <strong><code class=\"language-text\">클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다.</code></strong> 라는 문구에서 우리는 <em>“어휘적 환경의 <strong><code class=\"language-text\">조합</code></strong>”</em> 에 초점을 맞춰야한다.</p>\n<p>즉 상위 스코프 함수의 프로퍼티를 참조하지 않으면 우리는 클로저라고 부르지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> c <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n\n    <span class=\"token keyword\">return</span> c\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> bar\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> fn <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 3</span></code></pre></div>\n<p>여기 예제에서 <code class=\"language-text\">foo</code> 함수는 <code class=\"language-text\">bar</code> 함수를 리턴한다.\n하지만 <code class=\"language-text\">bar</code> 함수에서는 상위 스코프인 <code class=\"language-text\">foo</code> 함수의 어떤 프로퍼티도 참조하고 있지 않기 때문에 <code class=\"language-text\">bar</code> 함수는 클로저가 아니다.\nGC는 생명주기가 끝났고 어떤 참조도 받지 않는 <code class=\"language-text\">foo</code> 함수를 메모리에서 해제한다.</p>\n<h2>활용</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> increase <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> num <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">++</span>num\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">increase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">increase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 2</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">increase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 3</span></code></pre></div>\n<p>상태값 <code class=\"language-text\">num</code> 을 외부에 노출시키지 않으면서 안전하게 값을 변경한다.</p>\n<p><strong>이런식으로 상태가 의도치한게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 병경을 허용하여 상태를 안전하게 변경, 유지하기 위해 사용한다.</strong></p>\n<p>하지만 부모 함수에서 사용하고 있는 데이터는 GC에 의해 정리되지 않기 때문에 메모리를 차지한다는 단점과\n스코프에 따른 퍼포먼스 손해?</p>\n<p>React에서 클로저가 사용되는 경우 -> react hook에서 사용되고 있다.\n왜 React hook에서 클로저를 사용해야 하는가?</p>","frontmatter":{"title":"클로저(Closure)가 무엇인가요","date":null,"description":"클로저(Closure)가 무엇인가요?","tags":["Javascript"]}},"previous":{"fields":{"slug":"/study-js/프로토타입(prototype)이 무엇인가요/"},"frontmatter":{"title":"프로토타입(prototype)이 무엇인가요?"}},"next":{"fields":{"slug":"/study-js/폴리필(polyfill)이 무엇인가요/"},"frontmatter":{"title":"폴리필(polyfill)이 무엇인가요"}}},"pageContext":{"id":"f64cf150-2308-58cb-9dc5-3d5215314f77","previousPostId":"4cd71bb2-523e-58d4-96f3-8d8c009c24fd","nextPostId":"92519e1e-1b70-5577-955c-5bc058dbe527"}},"staticQueryHashes":["2841359383","3257411868"]}